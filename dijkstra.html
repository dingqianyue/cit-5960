<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm</title>
    <link rel="stylesheet" href="styles.css">
    <!-- Load MathJax and configure for proper display of math -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <script>
    MathJax = {
        tex: {
            inlineMath: [['\\(', '\\)']],
            displayMath: [['\\[', '\\]']]
        },
        svg: {
            fontCache: 'global'
        }
    };
    </script>
</head>
<body>
    <div class="content">
    <h1>Dijkstra's Algorithm</h1>
    <h2>Introduction</h2>
        <p>Dijkstra's Algorithm is a popular algorithm for finding the shortest path from a single source to all other nodes in a graph. It works on directed, weighted graphs and is designed to handle graphs with non-negative edge weights. The algorithm incrementally builds the shortest path by selecting the node with the smallest tentative distance and updating its neighbors.</p>
    
    <h2>Pseudocode for the Algorithm</h2>
    <pre>
        initialize shortest and pred arrays
        put all vertices in Q
        while Q != empty
            u = vertex in Q that has the smallest value in shortest
            delete u from Q
        for each v in adj(u)
            relax(u,v)

        relax(u,v)
        if shortest[v] > shortest[u] + weight(u,v)
            shortest[v] = pred[v] = u
    </pre>

    <h2>Array vs Heap Implementations</h2>
        <h3>Array-based Implementation</h3>
        <p>In an array-based implementation, the algorithm scans through all vertices in the priority queue to find the one with the smallest tentative distance. This results in a runtime of:</p>
        <p><strong>Runtime:</strong> \( O(V^2) \)</p>
        
        <h3>Heap-based Implementation (Min Heap)</h3>
        <p>Using a min-heap allows the algorithm to efficiently extract the vertex with the smallest distance and update the priority of neighboring vertices. This reduces the runtime for sparse graphs:</p>
        <p><strong>Runtime:</strong> \( O((V + E) \log V) \)</p>

        <h3>Comparison</h3>
        <p><strong>Array-based:</strong> Better for dense graphs where \( E \approx V^2 \).</p>
        <p><strong>Heap-based:</strong> More efficient for sparse graphs where \( E \ll V^2 \).</p>

    <h2>Key Notes</h2>
        <p>Dijkstra's Algorithm is only guaranteed to work correctly if all edge weights are non-negative.</p>
        <p>In graphs where some edge weights are negative, other algorithms like the Bellman-Ford algorithm should be used instead.</p>
        <p>However, if the only negative edges are coming from the source (implies that the graph is directed), then Dijkstra would work correctly because it considers the negative weights in the first iteration (thus not possible to have a smaller distance later).</p>
        <h3>The textbook uses a different version of Dijkstra's algorithm. It MIGHT have different results from most sources.</h3>
        <p>Specifically...the textbook version still checks the adjacent vertices even if the vertex is removed. Even though the final result is the same, the process might be different. You would have to consider the last step especially if asked to construct a graph where negative weights make the algorithm incorrect. </p>
    </div>
</body>
</html>         

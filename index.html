<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithmic Strategies</title>
    <link rel="stylesheet" href="styles.css">
    <!-- Load MathJax and configure -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [['\\[', '\\]']]
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
</head>
<body>
    <div class="content">
        <h1>Algorithmic Strategies</h1>
        
        <h2>Coin Change Making Problem</h2>
        <p>We have coins of the following denominations: \( \{1, 2, 4, 8, \ldots, 2^i, 2^n\} \).</p>
        <p>The goal is to make change for an amount \( A \) greater than \( 2^n \) using the least number of coins.</p>
        <p><strong>Claim:</strong> To optimize, it makes sense to take as many \( 2^n \) coins as possible.</p>
        <p><strong>Proof:</strong> Assume the "optimal solution" has \( C_0 \) coins of 1, \( C_1 \) coins of 2, \ldots, \( C_i \) coins of \( 2^i \), such that:
        \[
        C_0 \cdot 1 + C_1 \cdot 2 + C_2 \cdot 4 + \ldots + C_n \cdot 2^n = A
        \]
        Since we did not take as many \( 2^n \) coins as possible, we have:
        \[
        A - C_n \cdot 2^n \geq 2^n
        \]
        Hence, 
        \[
        C_0 + C_1 \cdot 2 + C_2 \cdot 4 + \ldots + C_{n-1} \cdot 2^{n-1} \geq 2^n
        \]
        By lemma, if this solution is optimal, none of these \( C_0, C_1, \ldots, C_{n-1} \) can be 2 or larger because 2 coins of \( 2^i \) can be replaced by just 1 coin of \( 2^{i+1} \). The sum of lower denominations is \( 2^n - 1 \), which defies the above inequality. Thus, a solution that does not use as many \( 2^n \) coins as possible cannot be optimal.</p>
        
        <h2>Minimum Spanning Tree (MST)</h2>
        <p>Given: An undirected weighted connected graph where vertices represent islands and edges represent proposed bridges.</p>
        <p>Goal: Find a spanning tree of minimum total weight in this graph, ensuring that:
        <ul>
            <li>You have paths between all island pairs.</li>
            <li>The total construction cost is minimized.</li>
        </ul>
        </p>
        <p><strong>Claim:</strong> We will not ever make cycles in our construction. The minimum cost will be obtained by picking a subset of edges that make a tree and include every vertex, thus forming a spanning tree.</p>
        <p>
            P vs NP Problems

Polynomial-time (P) Problems
P - solution of the problem can be found in polynomial time (there exists a solution)
examples: sorting, searching, shortest path algorithms.

Nondeterministic Polynomial-time (NP) Problems
example: prime factorization - can verify a factor of an integer in polynomial time, but do not know any polynomial time algorithm to factorize a given integer.


P is a subset of NP

0/1 Knapsack is a NP-Complete problem — pseudo-polynomial time
When the inputs are binary, its complexity becomes exponential
O(nW) is pseudo-polynomial.
The dynamic programming solution is linear in the value of W, but exponential in the length of W


Recitation 12
Question 1
1. If the edge weights are all distinct, Prim’s and Kruskal’s algorithm will give the same minimum spanning tree.
Answer: True. There is one unique MST in this situation.
(If all edge weights are distinct, there is one unique MST)
2. Given an undirected weighted connected graph and a vertex s as source, the pred array at the end of Dijkstra’s algorithm running from s and the pred array at the end of Prim’s algorithm that is run starting from s are guaranteed to be the same.
Answer: False. (If the total weights from s to a vertex v is greater than the other shorter path, the pred vertex is different. Prim’s just picks the minimum weights for individual edges.)

Question 2
Run Prim’s algorithm on the following graph starting at vertex A

Question 3
Review
P — can provide an answer in polynomial time
NP — can verify answer in polynomial time
P is a subset of NP
1. Finding the edit distance between two strings is a problem that is in P.
Answer: True. O(mn).

2. If a problem is solvable using dynamic programming, it is definitely in P.
Answer: False. 0/1 Knapsack is not in polynomial time. O(n * W) = O(O * 2^k)
3. To prove a problem is in P we need to come up with the most efficient algorithm to solve the problem.
Answer: False. As long as it’s polynomial time, it’s fine and it’s in P.
        </p>
    </div>
</body>
</html>

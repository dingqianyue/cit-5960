<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimum Spanning Tree</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="content">
        <h1>Minimum Spanning Tree (MST)</h1>
        <h2>MST</h2>
        <p>Given: An undirected weighted connected graph where vertices represent islands and edges represent proposed bridges.</p>
        <p>Goal: Find a spanning tree of minimum total weight in this graph, ensuring that:</p>
        <ul>
            <li>You have paths between all island pairs.</li>
            <li>The total construction cost is minimized.</li>
        </ul>
        <p><strong>Claim:</strong> We will not ever make cycles in our construction. The minimum cost will be obtained by picking a subset of edges that make a tree and include every vertex, thus forming a spanning tree.</p>

        <h2>Kruskal's Algorithm</h2>
        <p>
Kruskal's algorithm is a greedy algorithm that finds a minimum spanning tree for a connected weighted graph. It operates by sorting all the edges in the graph in non-decreasing order of their weights and adding them one by one to the spanning tree, ensuring that no cycles are formed, until the tree spans all vertices.</p>
        <pre>
            1. sort edges by weight in ascending order
            2. T = empty set
            3. loop over the edges in sorted order
            if adding the edge to T does not create a cycle in T,
            then go ahead and add it to T
            4. return T
        </pre>
        <p>Using DFS for cycle checking</p>
        <p>The bottleneck is the sorting step.</p>

        <h2>Union-Find (Disjoint-Set) Data Structure</h2>
        
        <h2>Prim's Algorithm</h2>
        <pre>
            Initialize the shortest array and the pred array
            Initialize a heap Q to contain all the vertices and use the shortest[v] for the key
            while Q is not null {
                u = deleteMin(Q)
                for all v in adj(u) {
                    if v in Q and weight(u, v) < shortest[v] {
                        shortest[v] = weight(u, v)
                        pred[v] = u
                    }
                }
            }
        </pre>
        <p>When the algorithm terminates, the min-priority queue Q is empty; the minimum spanning tree A for G is thus {{v, pred[v]} for all v in V - r}</p>
        <p>Similar to Dijkstra and greedy algorithms, build the MST by repeatedly finding the min cost to connect isolated vertices from the current frontier</p>
        <p>Once a vertex has been removed from the priority queue and included in the MST, its key value is considered final and not subject to further updates. This is because the key value represents the minimum cost needed to add the vertex to the MST, and once added, that vertex's inclusion is permanent.</p>
    </div>
</body>
</html>

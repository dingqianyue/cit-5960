<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>P vs NP Problems</title>
        <link rel="stylesheet" href="styles.css">
        <!-- Load MathJax and configure for proper display of math -->
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
        <script>
        MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
        </script>
    </head>
<body>
    <div class="content"> <!-- Ensure content is wrapped for consistent styling -->
        <h2>P vs NP Problems</h2>
        <h3>Polynomial-time (P) Problems</h3>
        <p>Problems where the solution can be found in polynomial time are categorized as P. Examples include sorting, searching, and shortest path algorithms.</p>

        <h3>Nondeterministic Polynomial-time (NP) Problems</h3>
        <p>An example is prime factorization, which allows for the verification of a factor of an integer in polynomial time, but no known polynomial time algorithm exists for factorizing a given integer.</p>

        <p><strong>P is a subset of NP</strong></p>

        <p>The 0/1 Knapsack problem is classified as NP-Complete. It operates in pseudo-polynomial time O(nW), where its complexity becomes exponential when inputs are binary. The dynamic programming solution is linear in the value of W, but exponential in the length of W.</p>

        <h2>Last Recitation (12)! Friday, April 26, 2024</h2>
        <h4>Question 1</h4>
        <ol>
            <li><strong>If the edge weights are all distinct, Prim’s and Kruskal’s algorithm will give the same minimum spanning tree.</strong></li>
                <p>True. There is one unique MST in this situation.</p>
            <li><strong>Given an undirected weighted connected graph and a vertex s as source, the pred array at the end of Dijkstra’s algorithm running from s and the pred array at the end of Prim’s algorithm that is run starting from s are guaranteed to be the same.</strong></li>
                <p>False. Prim’s selects minimum weights for individual edges, which can result in different pred vertices.</p>
        </ol>

        <h4>Question 2</h4>
        <p>Run Prim’s algorithm on the graph starting at vertex A.</p>
        <img src="rec12q2.jpg" alt="Recitation 12 Question 2" width="546" height="413">
        <p>Show the shortest and pred arrays.</p>

        <h4>Question 3</h4>
        <ul>
            <li>Finding the edit distance between two strings is a problem that is in P.</li>
                <p>True. O(mn), where m is the length of string 1 and n is the length of string 2.</p>
            <li>If a problem is solvable using dynamic programming, it is definitely in P.</li>
                <p>False. Example: 0/1 Knapsack is not in polynomial time, O(n * W) = O(n * 2^k)).</p>
            <li>To prove a problem is in P, we need to come up with the most efficient algorithm to solve the problem.</li>
                <p>False. As long as it’s polynomial time, it’s considered in P.</p>
        </ul>

        <h2>Last Lecture! Tuesday, April 30, 2024</h2>
        <p>P - class of problems with O(polynomial) with respect to input size</p>
        <h4>Input size conventions</h4>
        <p>Array — length</p>
        <p>Graph — # of vertices, # of edges</p>
        <p>String — # of chars</p>
        <p>***Single num — log(number)***</p>
        <p>NP</p>
        <p>NP-Hard</p>
        <p>NP-Complete</p>
        
        <p>We know O(nW) algorithm for 0/1 knapsack does not make this problem in P.</p>
        <h4>Decision Problem</h4>
        <p>A problem that has a yes/no output</p>
        <p>e.g. Hamiltonian path problem</p>
        <p>Given a graph undirected, does this graph have a Hamiltonian path (path containing all vertices)?</p>

        <h4>Optimization Problems</h4>
        <p>Problems where goal is to maximize/minimize</p>
        <p>e.g. shortest path, edit distance, 0/1 knapsack</p>

        <p>Note - if we can solve decision problems, we can often use those solutions to solve the optimization version</p>
        <p>Consider decision version of 0/1 knapsack</p>
        <p>Inputs: given capacity W knapsack</p>
        <p>item</p>
        <p>weight</p>
        <p>value</p>

        <p>Decision version asks can we get a value >= V by filling above knapsack</p>
        <h4>Question: Does solving 0/1 decision help to solve optimization version?</h4>
        <p>0, 1, 2, ..., K (first no)</p>
        <p>Binary search</p>
        <p>min 0 or 1</p>
        <p>max sum of all values</p>

        <h4>NP - defined for decision problems in the following manner</h4>
        <p>Given a YES instance of the decision problem and a certificate of this YES instance, the certificate can be *verified* in polynomial manner.</p>
        <p>(A certificate is a string that certifies the answer to a computation.)</p>
        <h4>DO NOT TRY TO SOLVE AN NP PROBLEM IN EXAM</h4>

        <h4>Question: Show Hamiltonian path problem is an element of NP</h4>
        <p>Assume we have a graph where there is some Hamiltonian path. Now we are given a certificate of this path as some order of vertices say v1, v2, ..., vn</p>
        <p>Now to check that this is a Hamiltonian path</p>
        <li>Check that it has all vertices. Runtime - even a silly algo O(n^2)</li>
        <li>Check if (v1, v2) is an edge, check if (v2, v3) is  an edge etc. </li>
        <p>Runtime: In adj matrix check (v1, v2) edge is O(1) time.</p>
        <p>In adj list check the whole thing takes O(n+m).</p>

        <h4>Question: Show decision version of 0/1 knapsack is in NP</h4>
        <p>input - W</p>
        <p>(wi, vi) - weights, values of items</p>
        <p>V</p>
        <p>Can we get at least value V</p>
        <p>Certificate - list of items that were picked to put in bag</p>
        <p>Verficiation - check that items do not exceed cap</p>
        <p>Sum up values. Check >= V</p>
        <p>Claim both checks are polynomial time</p>

        <p>Note - problems like 0/1 knapsack are NOT unsolved</p>
        <p>How many subsets of a set 2^n</p>

        <h4>P vs NP</h4>
        <p>Result: we know P is a subset of NP</p>
        <p>Intuition - if you can solve something in polynomial time, then verification in polynomial time is easy.</p>

        <p>We don't know if NP is a subset of P. This is unsolved.</p>
            <li>To show NP is not a subset of P what do we need to do?</li>
        <p>We would need to show some NP problem can NEVER be solved in polynomial time (near impossible...)</p>
        <li>To show NP is a subset of P, we would need to show every NP problem can be solved in polynomial time</li>

        <h4>NP-Hard Problems</h4>
        <p>A problem Q is an NP-Hard problem iff (if and only if) all NP problems can be solved if this problem Q can be solved formally - all NP problem "reduced to" Q.</p>
        <p>(A problem P is NP-Hard if for every problem L in NP, there is a polynomial-time reduction from L to P. This means that if an efficient (polynomial-time) algorithm exists for solving P, then an efficient algorithm can be derived for solving every problem in NP.)</p>
        <h4>Reduction</h4>
        <p>subset sum - S = {a1, a2, ..., an} (can be solved by dynamic programming)</p>
        <p>target t</p>
        <p>Question: does there exist a subset sums up to t</p>
        <p>Question: Given set S, does there exist a subset that sums up to exactly half the total summation of S, i.e. can we divide S into 2 equal partitions?</p>
        
    </div>
</body>
</html>
